## Проблемы и риски текущей REST-архитектуры (до перехода на Event-Driven)

| № | Проблема / риск                                                                                                                                                                                   | Почему это станет критично при +5 страховых компаний                                                               |
|---|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|
| 1 | **Синхронная «цепочка» запросов**: Core-app делает REST-запрос к ins-product-aggregator, а тот синхронно опрашивает _все_ страховые. Один «медленный» или упавший провайдер блокирует весь ответ. | Удвоится число провайдеров → медианное время ответа вырастет, частота таймаутов/5xx увеличится экспоненциально.    |
| 2 | **Редкие опросы + устаревшие тарифы**: Core-app тянет прайсы раз в 15 мин, Settlement — раз в сутки. Между запросами клиенты могут видеть неактуальные цены.                                      | Больше партнёров → чаще изменяются тарифы → выше риск продать полис по старой цене и получить финансовый разнобой. |
| 3 | **Дублирование данных** (Core-app и Settlement хранят копии тарифов локально). При рассинхроне — разные сервисы работают с разными версиями данных.                                               | Рост объёма данных усиливает вероятность рассинхрона и увеличивает время локального апдейта.                       |
| 4 | **Ночные batch-job’ы**: Settlement раз в сутки выгружает ВСЕ полисы из Core-app. Объём выгрузки будет расти и со временем может влиять на онлайновые запросы.                                     | +продажи ⇒ длинный heavy-read, шанс задушить продовую БД ночью (или в раннем утре по регионам).                    |
| 5 | **Жёсткая связанность REST API**: каждый сервис знает конкретный URL/схему другого. Любой breaking change требует синхронного деплоя всей цепочки.                                                | Увеличение числа интеграций ведёт к взрывному росту связей N·(N-1).                                                |
| 6 | **Пики нагрузки ударяют сразу по всей цепочке**: всплеск трафика на Core-app мгновенно передаётся aggregator-у → страховым.                                                                       | Страховые могут режать RPS; при отказе одного — падает весь user-flow.                                             |
| 7 | **Нет механизмов back-pressure**: если страховая отвечает медленно, Core-app занят ожиданием. В итоге поды умирают от OOM/restarts.                                                               | Больше провайдеров → больше шансов заблокировать все соединения и поймать каскадные перезапуски.                   |


## Как решаем?

| № | Что было больно                                                              | Что изменилось в новой схеме                                                                                   | Почему боль уходит                                                                                        |
|---|------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|
| 1 | **Синхронная «цепочка»**: один медленный провайдер блокирует весь REST-ответ | ins-product-aggregator обновляет тарифы асинхронно и публикует событие `tariff.changed` в Kafka                | Core-app и Settlement получают данные из очереди; медленный/упавший провайдер не влияет на запрос клиента |
| 2 | **Редкие опросы → устаревшие тарифы**                                        | Push-модель: тариф обновился → сразу `tariff.changed`                                                          | Тарифы становятся near-real-time — больше нет 15-мин/сутки лагов                                          |
| 3 | **Рассинхрон копий данных**                                                  | Используем **Transactional Outbox**: запись тарифа и событие выходят из одной транзакции                       | Версия в БД всегда совпадает с версией, ушедшей в событие; дубликатов/пропусков нет                       |
| 4 | **Ночные batch-job’ы & heavy-read**                                          | Core-app публикует `insurance.created` сразу после оформления; Settlement читает поток и агрегирует постепенно | Settlement не дергает Core-app и БД гигантским запросом, нагрузка размазана по времени                    |
| 5 | **Жёсткая связанность REST**                                                 | Сервисы общаются через топики (`tariff.changed`, `insurance.created`)                                          | Контракты = схемы событий (Avro/Protobuf). Можно менять внутреннее API без каскадных деплоев              |
| 6 | **Пик нагрузки → лавина на страховые**                                       | Клиентский пик идёт только в Core-app; Aggregator обновляет тарифы заранее и кэширует                          | Нет синхронной прокладки трафика до страховых, они не падают от всплесков                                 |
| 7 | **Нет back-pressure**                                                        | Kafka буферизует события, потребители читают с нужной скоростью                                                | Поддерживается естественный back-pressure, поды не ребутаются от OOM                                      |
| 8 | **Мониторинг сложен: кто дернул кого?**                                      | Все вызовы = события в Kafka; можно трейсить цепочку по offsets и ключам                                       | Ясный audit-trail, проще искать «где пропало»                                                             |
