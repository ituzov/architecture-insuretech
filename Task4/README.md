## Архитектурные решение

Сохраняем общий подход, который уже используется для работы с тарифами страховых.  
Выделяем новый сервис **osago-aggregator**, который:
- отправляет заявки в страховые компании,
- опрашивает ответы,
- возвращает частичные результаты в **core-app**.

Все остальные задачи по ОСАГО остаются в core-app.

---

## Решения по ключевым вопросам

### Нужно ли хранилище данных для osago-aggregator
Да, нужно. Оно:
- хранит данные о заявках, статусах и ответах страховых,
- позволяет реализовать Transactional Outbox для гарантии публикации событий (например, `osago.offer.updated`),
- даёт возможность аудитить историю изменений.

Выбор: PostgreSQL, как и у других агрегирующих сервисов.

---

### Какой API aggregator даёт core-app
- POST /osago/requests — создать новую заявку и запустить процесс,
- GET /osago/responses/{request_id} — отдать собранные на текущий момент предложения.

Важно: клиентский интерфейс показывает частичные данные по мере поступления, а не ждёт финализации всех страховых.

---

### Интеграция между core-app и osago-aggregator
- REST, point-to-point.
- Обязательно:
    - Circuit Breaker, чтобы не пробивать запросами недоступный сервис,
    - Timeout ≤ 65 секунд,
    - Retry с контролем идемпотентности (чтобы не дублировать операции).

---

### Интеграция фронтенда и core-app
- REST API (сетевые запросы с polling),
- Rate Limiting на стороне core-app, чтобы защититься от избыточных запросов клиента.

---

### Паттерны отказоустойчивости

| Зона                  | Решение                                                    |
|-----------------------|------------------------------------------------------------|
| core-app → aggregator | Circuit Breaker, Timeout, Retry с идемпотентностью         |
| aggregator → страховые | Timeout (макс. 60 сек), Circuit Breaker                    |
| фронт → core-app      | Rate Limiting (ограничение запросов с клиента)             |
| события (Kafka)       | Transactional Outbox + уникальные ключи для идемпотентности |

---

### Учёт многорепличности

Сервисы масштабируются горизонтально:
- aggregator использует общее хранилище, поэтому любой его экземпляр может обрабатывать заявку,
- события и запросы идут с уникальными ключами, чтобы гарантировать идемпотентность на уровне системы.
